// @floating-ui/core@1.7.4 downloaded from https://ga.jspm.io/npm:@floating-ui/core@1.7.4/dist/floating-ui.core.mjs

import{getSideAxis as t,getAlignmentAxis as e,getAxisLength as n,getSide as o,getAlignment as s,evaluate as c,getPaddingObject as i,rectToClientRect as r,min as l,clamp as a,getOppositeAlignmentPlacement as f,placements as m,getAlignmentSides as u,getOppositePlacement as d,getExpandedPlacements as g,getOppositeAxisPlacements as p,sides as h,max as y,getOppositeAxis as w}from"@floating-ui/utils";export{rectToClientRect}from"@floating-ui/utils";function x(c,i,r){let{reference:l,floating:a}=c;const f=t(i);const m=e(i);const u=n(m);const d=o(i);const g=f==="y";const p=l.x+l.width/2-a.width/2;const h=l.y+l.height/2-a.height/2;const y=l[u]/2-a[u]/2;let w;switch(d){case"top":w={x:p,y:l.y-a.height};break;case"bottom":w={x:p,y:l.y+l.height};break;case"right":w={x:l.x+l.width,y:h};break;case"left":w={x:l.x-a.width,y:h};break;default:w={x:l.x,y:l.y}}switch(s(i)){case"start":w[m]-=y*(r&&g?-1:1);break;case"end":w[m]+=y*(r&&g?-1:1);break}return w}async function v(t,e){var n;e===void 0&&(e={});const{x:o,y:s,platform:l,rects:a,elements:f,strategy:m}=t;const{boundary:u="clippingAncestors",rootBoundary:d="viewport",elementContext:g="floating",altBoundary:p=false,padding:h=0}=c(e,t);const y=i(h);const w=g==="floating"?"reference":"floating";const x=f[p?w:g];const v=r(await l.getClippingRect({element:(n=await(l.isElement==null?void 0:l.isElement(x)))==null||n?x:x.contextElement||await(l.getDocumentElement==null?void 0:l.getDocumentElement(f.floating)),boundary:u,rootBoundary:d,strategy:m}));const b=g==="floating"?{x:o,y:s,width:a.floating.width,height:a.floating.height}:a.reference;const A=await(l.getOffsetParent==null?void 0:l.getOffsetParent(f.floating));const R=await(l.isElement==null?void 0:l.isElement(A))&&await(l.getScale==null?void 0:l.getScale(A))||{x:1,y:1};const O=r(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:b,offsetParent:A,strategy:m}):b);return{top:(v.top-O.top+y.top)/R.y,bottom:(O.bottom-v.bottom+y.bottom)/R.y,left:(v.left-O.left+y.left)/R.x,right:(O.right-v.right+y.right)/R.x}}const b=async(t,e,n)=>{const{placement:o="bottom",strategy:s="absolute",middleware:c=[],platform:i}=n;const r=c.filter(Boolean);const l=await(i.isRTL==null?void 0:i.isRTL(e));let a=await i.getElementRects({reference:t,floating:e,strategy:s});let{x:f,y:m}=x(a,o,l);let u=o;let d={};let g=0;for(let n=0;n<r.length;n++){var p;const{name:c,fn:h}=r[n];const{x:y,y:w,data:b,reset:A}=await h({x:f,y:m,initialPlacement:o,placement:u,strategy:s,middlewareData:d,rects:a,platform:{...i,detectOverflow:(p=i.detectOverflow)!=null?p:v},elements:{reference:t,floating:e}});f=y!=null?y:f;m=w!=null?w:m;d={...d,[c]:{...d[c],...b}};if(A&&g<=50){g++;if(typeof A==="object"){A.placement&&(u=A.placement);A.rects&&(a=A.rects===true?await i.getElementRects({reference:t,floating:e,strategy:s}):A.rects);({x:f,y:m}=x(a,u,l))}n=-1}}return{x:f,y:m,placement:u,strategy:s,middlewareData:d}};const A=t=>({name:"arrow",options:t,async fn(o){const{x:r,y:f,placement:m,rects:u,platform:d,elements:g,middlewareData:p}=o;const{element:h,padding:y=0}=c(t,o)||{};if(h==null)return{};const w=i(y);const x={x:r,y:f};const v=e(m);const b=n(v);const A=await d.getDimensions(h);const R=v==="y";const O=R?"top":"left";const D=R?"bottom":"right";const P=R?"clientHeight":"clientWidth";const T=u.reference[b]+u.reference[v]-x[v]-u.floating[b];const E=x[v]-u.reference[v];const k=await(d.getOffsetParent==null?void 0:d.getOffsetParent(h));let L=k?k[P]:0;L&&await(d.isElement==null?void 0:d.isElement(k))||(L=g.floating[P]||u.floating[b]);const C=T/2-E/2;const B=L/2-A[b]/2-1;const H=l(w[O],B);const S=l(w[D],B);const F=H;const V=L-A[b]-S;const W=L/2-A[b]/2+C;const j=a(F,W,V);const z=!p.arrow&&s(m)!=null&&W!==j&&u.reference[b]/2-(W<F?H:S)-A[b]/2<0;const q=z?W<F?W-F:W-V:0;return{[v]:x[v]+q,data:{[v]:j,centerOffset:W-j-q,...z&&{alignmentOffset:q}},reset:z}}});function R(t,e,n){const c=t?[...n.filter((e=>s(e)===t)),...n.filter((e=>s(e)!==t))]:n.filter((t=>o(t)===t));return c.filter((n=>!t||(s(n)===t||!!e&&f(n)!==n)))}const O=function(t){t===void 0&&(t={});return{name:"autoPlacement",options:t,async fn(e){var n,i,r;const{rects:l,middlewareData:a,placement:f,platform:d,elements:g}=e;const{crossAxis:p=false,alignment:h,allowedPlacements:y=m,autoAlignment:w=true,...x}=c(t,e);const v=h!==void 0||y===m?R(h||null,w,y):y;const b=await d.detectOverflow(e,x);const A=((n=a.autoPlacement)==null?void 0:n.index)||0;const O=v[A];if(O==null)return{};const D=u(O,l,await(d.isRTL==null?void 0:d.isRTL(g.floating)));if(f!==O)return{reset:{placement:v[0]}};const P=[b[o(O)],b[D[0]],b[D[1]]];const T=[...((i=a.autoPlacement)==null?void 0:i.overflows)||[],{placement:O,overflows:P}];const E=v[A+1];if(E)return{data:{index:A+1,overflows:T},reset:{placement:E}};const k=T.map((t=>{const e=s(t.placement);return[t.placement,e&&p?t.overflows.slice(0,2).reduce(((t,e)=>t+e),0):t.overflows[0],t.overflows]})).sort(((t,e)=>t[1]-e[1]));const L=k.filter((t=>t[2].slice(0,s(t[0])?2:3).every((t=>t<=0))));const C=((r=L[0])==null?void 0:r[0])||k[0][0];return C!==f?{data:{index:A+1,overflows:T},reset:{placement:C}}:{}}}};const D=function(e){e===void 0&&(e={});return{name:"flip",options:e,async fn(n){var s,i;const{placement:r,middlewareData:l,rects:a,initialPlacement:f,platform:m,elements:h}=n;const{mainAxis:y=true,crossAxis:w=true,fallbackPlacements:x,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:b="none",flipAlignment:A=true,...R}=c(e,n);if((s=l.arrow)!=null&&s.alignmentOffset)return{};const O=o(r);const D=t(f);const P=o(f)===f;const T=await(m.isRTL==null?void 0:m.isRTL(h.floating));const E=x||(P||!A?[d(f)]:g(f));const k=b!=="none";!x&&k&&E.push(...p(f,A,b,T));const L=[f,...E];const C=await m.detectOverflow(n,R);const B=[];let H=((i=l.flip)==null?void 0:i.overflows)||[];y&&B.push(C[O]);if(w){const t=u(r,a,T);B.push(C[t[0]],C[t[1]])}H=[...H,{placement:r,overflows:B}];if(!B.every((t=>t<=0))){var S,F;const e=(((S=l.flip)==null?void 0:S.index)||0)+1;const n=L[e];if(n){const o=w==="alignment"&&D!==t(n);if(!o||H.every((e=>t(e.placement)!==D||e.overflows[0]>0)))return{data:{index:e,overflows:H},reset:{placement:n}}}let o=(F=H.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])==null?void 0:F.placement;if(!o)switch(v){case"bestFit":{var V;const e=(V=H.filter((e=>{if(k){const n=t(e.placement);return n===D||n==="y"}return true})).map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])==null?void 0:V[0];e&&(o=e);break}case"initialPlacement":o=f;break}if(r!==o)return{reset:{placement:o}}}return{}}}};function P(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function T(t){return h.some((e=>t[e]>=0))}const E=function(t){t===void 0&&(t={});return{name:"hide",options:t,async fn(e){const{rects:n,platform:o}=e;const{strategy:s="referenceHidden",...i}=c(t,e);switch(s){case"referenceHidden":{const t=await o.detectOverflow(e,{...i,elementContext:"reference"});const s=P(t,n.reference);return{data:{referenceHiddenOffsets:s,referenceHidden:T(s)}}}case"escaped":{const t=await o.detectOverflow(e,{...i,altBoundary:true});const s=P(t,n.floating);return{data:{escapedOffsets:s,escaped:T(s)}}}default:return{}}}}};function k(t){const e=l(...t.map((t=>t.left)));const n=l(...t.map((t=>t.top)));const o=y(...t.map((t=>t.right)));const s=y(...t.map((t=>t.bottom)));return{x:e,y:n,width:o-e,height:s-n}}function L(t){const e=t.slice().sort(((t,e)=>t.y-e.y));const n=[];let o=null;for(let t=0;t<e.length;t++){const s=e[t];!o||s.y-o.y>o.height/2?n.push([s]):n[n.length-1].push(s);o=s}return n.map((t=>r(k(t))))}const C=function(e){e===void 0&&(e={});return{name:"inline",options:e,async fn(n){const{placement:s,elements:a,rects:f,platform:m,strategy:u}=n;const{padding:d=2,x:g,y:p}=c(e,n);const h=Array.from(await(m.getClientRects==null?void 0:m.getClientRects(a.reference))||[]);const w=L(h);const x=r(k(h));const v=i(d);function b(){if(w.length===2&&w[0].left>w[1].right&&g!=null&&p!=null)return w.find((t=>g>t.left-v.left&&g<t.right+v.right&&p>t.top-v.top&&p<t.bottom+v.bottom))||x;if(w.length>=2){if(t(s)==="y"){const t=w[0];const e=w[w.length-1];const n=o(s)==="top";const c=t.top;const i=e.bottom;const r=n?t.left:e.left;const l=n?t.right:e.right;const a=l-r;const f=i-c;return{top:c,bottom:i,left:r,right:l,width:a,height:f,x:r,y:c}}const e=o(s)==="left";const n=y(...w.map((t=>t.right)));const c=l(...w.map((t=>t.left)));const i=w.filter((t=>e?t.left===c:t.right===n));const r=i[0].top;const a=i[i.length-1].bottom;const f=c;const m=n;const u=m-f;const d=a-r;return{top:r,bottom:a,left:f,right:m,width:u,height:d,x:f,y:r}}return x}const A=await m.getElementRects({reference:{getBoundingClientRect:b},floating:a.floating,strategy:u});return f.reference.x!==A.reference.x||f.reference.y!==A.reference.y||f.reference.width!==A.reference.width||f.reference.height!==A.reference.height?{reset:{rects:A}}:{}}}};const B=new Set(["left","top"]);async function H(e,n){const{placement:i,platform:r,elements:l}=e;const a=await(r.isRTL==null?void 0:r.isRTL(l.floating));const f=o(i);const m=s(i);const u=t(i)==="y";const d=B.has(f)?-1:1;const g=a&&u?-1:1;const p=c(n,e);let{mainAxis:h,crossAxis:y,alignmentAxis:w}=typeof p==="number"?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:p.mainAxis||0,crossAxis:p.crossAxis||0,alignmentAxis:p.alignmentAxis};m&&typeof w==="number"&&(y=m==="end"?w*-1:w);return u?{x:y*g,y:h*d}:{x:h*d,y:y*g}}const S=function(t){t===void 0&&(t=0);return{name:"offset",options:t,async fn(e){var n,o;const{x:s,y:c,placement:i,middlewareData:r}=e;const l=await H(e,t);return i===((n=r.offset)==null?void 0:n.placement)&&(o=r.arrow)!=null&&o.alignmentOffset?{}:{x:s+l.x,y:c+l.y,data:{...l,placement:i}}}}};const F=function(e){e===void 0&&(e={});return{name:"shift",options:e,async fn(n){const{x:s,y:i,placement:r,platform:l}=n;const{mainAxis:f=true,crossAxis:m=false,limiter:u={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...d}=c(e,n);const g={x:s,y:i};const p=await l.detectOverflow(n,d);const h=t(o(r));const y=w(h);let x=g[y];let v=g[h];if(f){const t=y==="y"?"top":"left";const e=y==="y"?"bottom":"right";const n=x+p[t];const o=x-p[e];x=a(n,x,o)}if(m){const t=h==="y"?"top":"left";const e=h==="y"?"bottom":"right";const n=v+p[t];const o=v-p[e];v=a(n,v,o)}const b=u.fn({...n,[y]:x,[h]:v});return{...b,data:{x:b.x-s,y:b.y-i,enabled:{[y]:f,[h]:m}}}}}};const V=function(e){e===void 0&&(e={});return{options:e,fn(n){const{x:s,y:i,placement:r,rects:l,middlewareData:a}=n;const{offset:f=0,mainAxis:m=true,crossAxis:u=true}=c(e,n);const d={x:s,y:i};const g=t(r);const p=w(g);let h=d[p];let y=d[g];const x=c(f,n);const v=typeof x==="number"?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const t=p==="y"?"height":"width";const e=l.reference[p]-l.floating[t]+v.mainAxis;const n=l.reference[p]+l.reference[t]-v.mainAxis;h<e?h=e:h>n&&(h=n)}if(u){var b,A;const t=p==="y"?"width":"height";const e=B.has(o(r));const n=l.reference[g]-l.floating[t]+(e&&((b=a.offset)==null?void 0:b[g])||0)+(e?0:v.crossAxis);const s=l.reference[g]+l.reference[t]+(e?0:((A=a.offset)==null?void 0:A[g])||0)-(e?v.crossAxis:0);y<n?y=n:y>s&&(y=s)}return{[p]:h,[g]:y}}}};const W=function(e){e===void 0&&(e={});return{name:"size",options:e,async fn(n){var i,r;const{placement:a,rects:f,platform:m,elements:u}=n;const{apply:d=()=>{},...g}=c(e,n);const p=await m.detectOverflow(n,g);const h=o(a);const w=s(a);const x=t(a)==="y";const{width:v,height:b}=f.floating;let A;let R;if(h==="top"||h==="bottom"){A=h;R=w===(await(m.isRTL==null?void 0:m.isRTL(u.floating))?"start":"end")?"left":"right"}else{R=h;A=w==="end"?"top":"bottom"}const O=b-p.top-p.bottom;const D=v-p.left-p.right;const P=l(b-p[A],O);const T=l(v-p[R],D);const E=!n.middlewareData.shift;let k=P;let L=T;(i=n.middlewareData.shift)!=null&&i.enabled.x&&(L=D);(r=n.middlewareData.shift)!=null&&r.enabled.y&&(k=O);if(E&&!w){const t=y(p.left,0);const e=y(p.right,0);const n=y(p.top,0);const o=y(p.bottom,0);x?L=v-2*(t!==0||e!==0?t+e:y(p.left,p.right)):k=b-2*(n!==0||o!==0?n+o:y(p.top,p.bottom))}await d({...n,availableWidth:L,availableHeight:k});const C=await m.getDimensions(u.floating);return v!==C.width||b!==C.height?{reset:{rects:true}}:{}}}};export{A as arrow,O as autoPlacement,b as computePosition,v as detectOverflow,D as flip,E as hide,C as inline,V as limitShift,S as offset,F as shift,W as size};

